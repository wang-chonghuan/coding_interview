package org.C_Hashing;

/*
given an array of positive integers nums and an integer k, find the number of subarrays with exactly k odd numbers in
 them.
 找到恰好有k个奇数个数字的子序列的个数

 这段代码提供了一个优雅且高效的解决方案来解决我们的问题。首先，`numberOfSubarrays`函数通过调用`atMost`函数两次并使用结果进行减法运算来找到包含恰好`k`个奇数的子数组的数量。具体来说，`atMost(A, k)`计算包含至多`k`个奇数的子数组的数量，而`atMost(A, k - 1)`计算包含至多`k-1`个奇数的子数组的数量。它们的差值就等于包含恰好`k`个奇数的子数组的数量，这是因为如果你从包含至多`k`个奇数的子数组的数量中减去包含至多`k-1`个奇数的子数组的数量，你将得到恰好包含`k`个奇数的子数组的数量。接下来我们看`atMost`函数，它使用了双指针技术来遍历数组。在这里，`i`和`j`分别是滑动窗口的左右边界，并且在每次迭代中，`j`都会向右移动一位，这意味着我们正在探讨一个新的元素是否可以被加入当前的子数组中。如果新元素是奇数（即`A[j] % 2`为1），我们从`k`中减去1，因为我们现在有一个额外的奇数要考虑。接下来的`while`循环检查`k`是否小于0，如果是的话，那意味着我们的子数组包含太多的奇数，我们需要移动左边界`i`来排除一些奇数。`i`将一直向右移动，直到`k`大于或等于0，这是通过在每次迭代中将`i`指向的元素是否为奇数的信息加回`k`来实现的。最后，`res`增加了`j - i + 1`，这实际上是加上了以`A[j]`结尾的、满足条件的子数组的数量。这是因为，每当我们添加一个新元素到子数组时，我们实际上是在创建`j - i + 1`个新的符合条件的子数组。一旦我们完成对数组的遍历，`atMost`函数就会返回子数组的总数，然后这些值会被用来在`numberOfSubarrays`函数中计算并返回结果。
 */
public class CountingE5N1248 {
    public int numberOfSubarrays(int[] nums, int k) {
        return atMost(nums, k) - atMost(nums, k - 1);
    }

    // atMost(A, k)`计算包含不超过`k`个奇数的子数组的数量
    public int atMost(int[] nums, int k) {
        int res = 0;
        int i = 0;
        int n = nums.length;
        // 遍历数组的每一个元素，j作为子数组的右边界
        for(int j = 0; j < n; j++) {
            // 要保证该子数组不超过k个奇数，所以减去一个奇数名额
            if(nums[j] % 2 == 1) {
                k--;
            }
            // 如果k小于0,即当前子数组中奇数的数量太多，超过了减少奇数的数量，把以前删掉的找回来
            while(k < 0) {
                if(nums[i] % 2 == 1) {
                    k++;
                }
                i++;
            }
            // 以nums[j]结尾的符合条件的子数组的数量是j-i+1
            /*
            当我们考虑以 \( A[j] \) 结尾的子数组时，我们希望计算所有符合条件的这类子数组的数量。在这个问题的上下文中，一旦确定了子数组的结束位置 \( j \)，满足条件的子数组的开始位置 \( i \) 必须在 \([i, j]\) 的范围内。每一个在这个范围内的开始位置都形成了一个有效的、以 \( A[j] \) 结尾的子数组。我们可以通过 \( j - i + 1 \) 计算这些子数组的总数量，以此类推，每减小 \( i \) 一个单位，我们就获得一个新的、以 \( A[j] \) 结尾的子数组，它仍然满足至多包含 \( k \) 个奇数的条件。因此，总的符合条件的子数组数量就是 \( j - i + 1 \)，因为 \( i \) 可以在 \([i, j]\) 的闭区间内取值。
             */
            res += (j - i + 1);
        }
        return res;
    }
}
